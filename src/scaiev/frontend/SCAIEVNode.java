package scaiev.frontend;

import java.util.EnumSet;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Pattern;
import scaiev.pipeline.ScheduleFront;

public class SCAIEVNode {
  public enum AdjacentNode {
    none(""),                                   // the base node
    spawnAllowed("_spawnAllowed"),              // for spawn, optional, synchronously keeps spawn fire active
    validReq("_validReq", AdjacentNode.none),   // ! considered to trigger node and be mandatory
    cancelReq("_cancelReq"),                    // automatically generated by SCAIE-V, set if an ISAX proceeds while keeping validReq low
    validData("_validData", AdjacentNode.none), // Currently used for wrrd/wrrd_user_node data hazard mechanism. Not mandatory
    validResp("_validResp", AdjacentNode.none), // ! considered to return valid response from core to ISAX
    validHandshakeResp("_validHandshakeResp", AdjacentNode.none), // handshake response, generated with validResp or spawnAllowed nodes
    addr("_addr"),
    addrReq("_addr_valid", AdjacentNode.addr),
    size("_size"),               // Size for memory accesses, sampled together with addr
    defaultAddr("_defaultAddr"), // for exp for memory accesses when SCAL needs to get from core the adress
    addrCommited("_addrCommited"),
    isWrite("_write"), // for memory transctions for example, to make sure it is a write mem transaction
    instrID("_id") // input for hazard handling/scoreboard
    ;

    public final String suffix;
    /**
     * Set to non-null AdjacentNode if this adjacent node indicates the validity of some other node;
     * Special semantics are needed to differentiate between validReq, validData, validResp for instance.
     */
    public final AdjacentNode validMarkerFor;

    public boolean isValidMarker() { return validMarkerFor != null; }

    private AdjacentNode(String suffix) {
      this.suffix = suffix;
      this.validMarkerFor = null;
    }
    private AdjacentNode(String suffix, AdjacentNode validMarkerFor) {
      this.suffix = suffix;
      this.validMarkerFor = validMarkerFor;
    }
  }
  public enum NodeTypeTag {
    /**
       The node is a read result that remains valid for the lifetime of an instruction. Should not be combined with
       {@link NodeTypeTag#nonStaticReadResult}.
     */
    staticReadResult,
    /**
     * The node is a read result requested by an instruction (e.g. from memory); the value could get overridden if the instruction sends
     * another request. Should not be combined with {@link NodeTypeTag#staticReadResult}.
     */
    nonStaticReadResult,
    /** The node represents/adds to some per-stage status of the pipeline (stall, flush, etc.). */
    perStageStatus,
    /** No SCAL&lt;-&gt;core interface should be generated for this node */
    noCoreInterface,
    /**
       By default, the core is assumed not to provide this adjacent node even if it provides the base node. It must be explicitly noted in
       the core's datasheet to support it.
     */
    defaultNotprovidedByCore,
    /** Port nodes of this (non-adj) base node are supported. */
    supportsPortNodes,
    /** The node is a port node, the name format being "&lt;base node name&gt;_port&lt;port name&gt;&lt;adj suffix&gt;". */
    isPortNode,
    /** The node is only used to mark constraints, such as for all user nodes. */
    constraintMarkerOnlyNode,
    /** The node is used max. once per instruction, but may be present in different stages. */
    accumulatesUntilCommit
  }

  // private vars
  private AdjacentNode adjSignal =
      AdjacentNode.none; // default value. If it doesn't have any parent node, than this value has to be AdjacentNode.none

  // public vars
  // Node properties
  public int size;
  public ScheduleFront commitStage = new ScheduleFront();
  /** default orientation: true means 'is an input to the core', i.e. 'ISAX->SCAL' and/or 'SCAL->Core' */
  public boolean isInput;
  public String name = "";
  public int nonuniqueID = 0;
  /** Does this node belong to another node (logically) */
  public String nameParentNode = "";
  /**
   * for exp. WrStall should have 1 interf/stage to ISAX, but WrRD an interface for each ISAX result. So for WrStall this variable would be
   * true and for WrRD false. By default Wr Nodes have false and Rd Nodes true
   */
  public boolean oneInterfToISAX = false;
  /**
   * By default true for all spawn nodes.
   */
  public boolean allowMultipleSpawn = false;
  /**
   * For example, rdmem and wrmem are cousin nodes. Spawn fire logic must be computed for bnoth these nodes because they use the same
   * resources
   */
  public String nameCousinNode = "";
  /** Don't generate interface to ISAX for this node */
  public boolean noInterfToISAX = false;
  /** used when nameCousinNode not empty. For exp for WrMem and RdMem, familyName = Mem */
  public String familyName = "";
  /** Datahazard required? For exp for WrRD spawn */
  public boolean DH = false;
  /** used by user-added nodes (number of regfile elements) */
  public int elements = 0;
  /** the adjacent node that marks an instance of this node as valid (validReq or addrReq) */
  public AdjacentNode validBy = AdjacentNode.none;
  /** This interf MUST be supported to the core. For exp _write for memory spawn */
  public boolean mustToCore = false;
  public boolean mandatory = false;
  /** The set of tags that applies to this node */
  public Set<NodeTypeTag> tags = EnumSet.noneOf(NodeTypeTag.class);

  // Other public vars
  public static final String spawnSuffix = "_spawn";   //
  public static final String portbaseSuffix = "_port"; //"_port<n>" is the full suffix for port nodes
  public static final Pattern portnamePattern = Pattern.compile("^[a-zA-Z0-9]+$");
  /**
   * Constructor for when just the name is relevant (size, input/output irrelevant)
   * @param name
   */
  public SCAIEVNode(String name) {
    this.name = name;
    this.nonuniqueID = name.hashCode();
    this.familyName = name;
    this.adjSignal = AdjacentNode.none;
  }

  /**
   * Constructor of SCAIEVNode. Name has to be unique (not used by other SCAIEVNodes, as it is used by the hashCode() function.
   * @param name
   * @param size
   * @param isInput default orientation: true means 'is an input to the core', i.e. 'ISAX->SCAL' and/or 'SCAL->Core'
   */
  public SCAIEVNode(String name, int size, boolean isInput) {
    this.size = size;
    this.isInput = isInput;
    this.name = name;
    this.nonuniqueID = name.hashCode();
    if (isInput)
      oneInterfToISAX = false;
    else
      oneInterfToISAX = true;
    this.familyName = name;
    this.adjSignal = AdjacentNode.none;
  }

  /**
   * Constructor of SCAIEVNode for child nodes. Name is generated automatically based on parent node and adjNode.
   * @param parentNode the parent node
   * @param adjNode the adjacent node to generate (may be {@link AdjacentNode#none})
   * @param size the size in bits
   * @param isInput default orientation: is an input to the core
   * @param isSpawn if this node is a spawn variant (will create an appropriate name)
   */
  public SCAIEVNode(SCAIEVNode parentNode, AdjacentNode adjNode, int size, boolean isInput, boolean isSpawn) {
    this.size = size;
    this.isInput = isInput;
    if (isSpawn && !parentNode.isSpawn())
      this.name = CreateSpawnName(parentNode) + adjNode.suffix;
    else
      this.name = parentNode.name + adjNode.suffix;
    if (parentNode.isSpawn())
      allowMultipleSpawn = parentNode.allowMultipleSpawn;
    else if (isSpawn)
      allowMultipleSpawn = true;
    this.nonuniqueID = name.hashCode();
    this.nameParentNode = parentNode.name;
    this.adjSignal = adjNode;
    if (isInput)
      oneInterfToISAX = false;
    else
      oneInterfToISAX = true;
    this.familyName = parentNode.familyName;
    this.nameCousinNode = parentNode.nameCousinNode;
    this.DH = parentNode.DH;
    this.elements = parentNode.elements;
  }

  /**
   * Clones a SCAIEVNode object.
   * @param node
   * @param nameOverride an optional new name for the returned node
   * @param keepParent if true, will keep the node's parent; otherwise, the returned node will be set as having `node` as parent
   * @return
   */
  public static SCAIEVNode CloneNode(SCAIEVNode node, Optional<String> nameOverride, boolean keepParent) {
    SCAIEVNode ret = new SCAIEVNode(node, AdjacentNode.none, node.size, node.isInput, node.isSpawn());
    ret.nameParentNode = keepParent ? node.nameParentNode : node.name;
    ret.name = nameOverride.isPresent() ? nameOverride.get() : node.name;
    ret.nonuniqueID = ret.name.hashCode();
    ret.adjSignal = node.adjSignal;
    ret.tags.addAll(node.tags);

    ret.commitStage = node.commitStage;
    ret.oneInterfToISAX = node.oneInterfToISAX;
    ret.allowMultipleSpawn = node.allowMultipleSpawn;
    ret.nameCousinNode = node.nameCousinNode;
    ret.noInterfToISAX = node.noInterfToISAX;
    ret.DH = node.DH;
    ret.elements = node.elements;
    ret.validBy = node.validBy;
    ret.mustToCore = node.mustToCore;
    ret.mandatory = node.mandatory;
    return ret;
  }

  /**
   * Creates a port node. If baseNodeWithAdj is adjacent, the returned port node will be created as an adjacent to the port base node.
   * The port node name will follow the format "&lt;base node name&gt;_port&lt;port name&gt;&lt;adj suffix&gt;".
   * NOTE: Does not check for {@link NodeTypeTag#supportsPortNodes}.
   * @param baseNodeWithAdj the base portless node (or an adjacent node)
   * @param portName the port name
   * @return
   */
  public static SCAIEVNode makePortNodeOf(SCAIEVNode baseNodeWithAdj, String portName) {
    if (!portnamePattern.matcher(portName).matches()) {
      throw new IllegalArgumentException("The given port name does not match the pattern '" + portnamePattern.toString() + "'");
    }
    String baseNodeNonadjName = baseNodeWithAdj.isAdj() ? baseNodeWithAdj.nameParentNode : baseNodeWithAdj.name;
    String portBaseNodeName = baseNodeNonadjName + portbaseSuffix + portName;
    String adjPortNodeName = portBaseNodeName + baseNodeWithAdj.getAdj().suffix;
    SCAIEVNode ret = CloneNode(baseNodeWithAdj, Optional.of(adjPortNodeName), true);
    ret.nameParentNode = ret.isAdj() ? portBaseNodeName : baseNodeNonadjName;
    ret.tags.remove(NodeTypeTag.supportsPortNodes);
    ret.tags.add(NodeTypeTag.isPortNode);
    return ret;
  }

  /**
   * @return this, or a cloned SCAIEVNode named to match the node family
   */
  public SCAIEVNode makeFamilyNode() {
    if (!canRepresentAsFamily())
      return this;
    return CloneNode(this, Optional.of(this.replaceRadixNameWith(familyName)), true);
  }

  /**
   * Determines whether this node is a valid signal for some logic or other node.
   * For pipelining and reset logic, this indicates that the signal should default to 0.
   * Nodes with adj validReq, validData, validResp, addrReq are always considered as 'valid nodes'.
   */
  public boolean isValidNode() { return adjSignal.isValidMarker(); }

  /**
   * Determines whether this node can be (or already is) converted to a family node.
   * Specific example: WrMem write data and RdMem read data channels will remain separate,
   *  whereas WrMem_validReq and RdMem_validReq will be merged to Mem_validReq.
   */
  public boolean canRepresentAsFamily() {
    return !nameCousinNode.isEmpty() && isAdj() &&
        getAdj() != AdjacentNode.defaultAddr; // HACK: May want to use a node attribute instead of isAdj.
  }

  /**
   * When generating common module, it is mandatory to have the AdjacentNode as given in this function. For example, in case of WrRD, it is
   * mandatory to compute valid signal. This will be used by core as RegFile[rd] = WrRd_valid ? WrRD : deafult_logic ==> it is mandatory in
   * common logic module to have WrRd_valid signal
   * @return
   */
  public boolean DefaultMandatoryAdjSig() {
    if (adjSignal == AdjacentNode.validReq ||
        (isSpawn() && (adjSignal == AdjacentNode.validResp || adjSignal == AdjacentNode.validHandshakeResp)) ||
        (adjSignal == AdjacentNode.addrReq && elements > 1))
      return true;
    else
      return false;
  }

  /**
   * Function to generate the same SCAIEVNode but with !isInput
   * @return
   */
  public SCAIEVNode NodeNegInput() {
    SCAIEVNode ret = CloneNode(this, Optional.empty(), true);
    ret.isInput = !ret.isInput;
    String newName = this.name;
    SCAIEVNode returnNode = new SCAIEVNode(newName, this.size, !this.isInput);
    returnNode.adjSignal = this.adjSignal;
    returnNode.familyName = this.familyName;
    returnNode.nameCousinNode = this.nameCousinNode;
    returnNode.allowMultipleSpawn = this.allowMultipleSpawn;
    returnNode.nameParentNode = this.nameParentNode;
    returnNode.oneInterfToISAX = this.oneInterfToISAX;
    returnNode.DH = this.DH;
    return returnNode;
  }

  /**
   * is this the spawn variant of node1?
   * @param node1
   * @return
   */
  public boolean isSpawnOf(SCAIEVNode node1) { return this.name.contains(CreateSpawnName(node1)); }

  /**
   * is this a spawn node?
   * @return
   */
  public boolean isSpawn() { return this.name.contains(spawnSuffix); }

  /**
   * Creates a spawn variant name of a given non-spawn node
   * @param parentNode
   */
  private String CreateSpawnName(SCAIEVNode parentNode) { return parentNode.name + spawnSuffix; }
  public String replaceRadixNameWith(String replace) {
    String suffix = getAdj().suffix;
    if (this.isSpawn()) {
      suffix = spawnSuffix + suffix;
    }
    assert (this.name.endsWith(suffix));
    return replace + "_" + suffix;
  }

  public AdjacentNode getAdj() {
    if (this.nameParentNode.isEmpty())
      return AdjacentNode.none;
    else
      return this.adjSignal;
  }

  public boolean isAdj() { return !this.nameParentNode.isEmpty() && this.adjSignal != AdjacentNode.none; }

  public boolean HasParentNode(SCAIEVNode checkNode) { return checkNode.name.equals(this.nameParentNode); }
  @Override
  public String toString() {
    return name;
  }

  @Override
  public int hashCode() {
    return nonuniqueID;
  }

  @Override
  public boolean equals(Object obj) {
    if (obj instanceof String)
      return this.name.equals(obj);
    if (!(obj instanceof SCAIEVNode))
      return false;
    return (this.name.equals(((SCAIEVNode)obj).name));
  }
}
