package scaiev.frontend;

import java.util.EnumSet;
import java.util.Optional;
import java.util.Set;

import scaiev.pipeline.ScheduleFront;

public class SCAIEVNode {
	public enum AdjacentNode {
		none("", false),                      // ! considered null
		spawnAllowed("_spawnAllowed", false),  // for spawn, optional, synchronously keeps spawn fire active 
		validReq("_validReq", true),           // ! considered to trigger node and be mandatory
		cancelReq("_cancelReq", false),        // automatically generated by SCAIE-V, set if an ISAX proceeds while keeping validReq low
		validData("_validData", true),	       // Currently used for wrrd/wrrd_user_node data hazard mechanism. Not mandatory
		validResp("_validResp", true),         // ! considered to return valid response from core to ISAX
		addr("_addr", false),
		addrReq("_addr_valid", true),
		size("_size", false),                  // Size for memory accesses, sampled together with addr
		defaultAddr("_defaultAddr", false),    // for exp for memory accesses when SCAL needs to get from core the adress
		addrCommited("_addrCommited", false),
		isWrite("_write", false);              // for memory transctions for example, to make sure it is a write mem transaction
		
		public final String suffix;
		/** Set if this adjacent node indicates the validity of some other node */
		public final boolean isValidMarker;
		
		private AdjacentNode(String suffix, boolean isValidMarker) {
			this.suffix = suffix;
			this.isValidMarker = isValidMarker;
		}
	}
	public enum NodeTypeTag {
		/** The node is a read result that remains valid for the lifetime of an instruction. Should not be combined with {@link NodeTypeTag#nonUniqueReadResult}. */
		staticReadResult,  
		/** 
		 * The node is a read result requested by an instruction (e.g. from memory); the value could get overridden if the instruction sends another request.
		 * Should not be combined with {@link NodeTypeTag#staticReadResult}. 
		 */
		nonStaticReadResult,
		/** The node represents/adds to some per-stage status of the pipeline (stall, flush, etc.). */
		perStageStatus,
		/** No SCAL<->core interface should be generated for this node */
		noCoreInterface,
		/** By default, the core is assumed not to provide this adjacent node even if it provides the base node. It must be explicitly noted in the core's datasheet to support it. */
		defaultNotprovidedByCore,
	}
	
	// private vars
	private AdjacentNode adjSignal = AdjacentNode.none; // default value. If it doesn't have any parent node, than this value has to be AdjacentNode.none
	
	// public vars
	// Node properties
	public int size; 
	public ScheduleFront commitStage = new ScheduleFront();
	/** default orientation: true means 'is an input to the core', i.e. 'ISAX->SCAL' and/or 'SCAL->Core' */
	public boolean isInput; 
	public String name = "";
	public int uniqueID = 0;
	/** Does this node belong to another node (logically) */
	public String nameParentNode = ""; 
	/** for exp. WrStall should have 1 interf/stage to ISAX, but WrRD an interface for each ISAX result. So for WrStall this variable would be true and for WrRD false. By default Wr Nodes have false and Rd Nodes true */
	public boolean oneInterfToISAX = false;
	/** By default true for all spawn nodes. WrPC_spawn should have it false, as no multiple spawn instructions are allowed to concurrently update PC..it doesn't make sense */
	public boolean allowMultipleSpawn = false;
	/** For example, rdmem and wrmem are cousin nodes. Spawn fire logic must be computed for bnoth these nodes because they use the same resources */
	public String nameCousinNode = "";
	/** Don't generate interface to ISAX for this node */
	public boolean noInterfToISAX = false;
	/** used when nameCousinNode not empty. For exp for WrMem and RdMem, familyName = Mem */
	public String familyName = "";
	/** Datahazard required? For exp for WrRD spawn */
	public boolean DH = false;
	/** used by user-added nodes (number of regfile elements) */
	public int elements = 0;
	/** instead of creating a graph with parents to parent and so on, this is used if this is already an adj signal but is attached to other adj signal. For exp for wrmem_addr_valid this would be wrmem_addr */
	public String attachedNode = "";
	/** the adjacent node that marks an instance of this node as valid (validReq or addrReq) */
	public AdjacentNode validBy = AdjacentNode.none;
	/** This interf MUST be supported to the core. For exp _write for memory spawn */
	public boolean mustToCore = false;
	public boolean mandatory = false;
	/** Set if this node should be considered a 'valid node' for some other node/logic with default value zero. Nodes with adj validReq, validData, validResp, addrReq are always considered as 'valid nodes'. */
	public boolean isOtherValidNode = false;
	/** The set of tags that applies to this node */
	public Set<NodeTypeTag> tags = EnumSet.noneOf(NodeTypeTag.class);
	
	// Other public vars
	public static final String spawnSuffix = "_spawn";	// 
	/**
	 * when just name is relevant & size & input irrelevant
	 * @param name
	 */
	public SCAIEVNode (String name) {
		this.name = name;
		this.uniqueID = name.hashCode();
		this.familyName = name;
		this.adjSignal = AdjacentNode.none;
	}
	
	/**
	 * Constructor of SCAIEVNode. Name has to be unique (not used by other SCAIEVNodes, as it is used by the hashCode() function.  
	 * @param uniqueID
	 * @param name
	 * @param size
	 * @param isInput default orientation: true means 'is an input to the core', i.e. 'ISAX->SCAL' and/or 'SCAL->Core'
	 */
	public SCAIEVNode (String name, int size, boolean isInput) {
		this.size = size; 
		this.isInput = isInput;
		this.name = name;
		this.uniqueID = name.hashCode();
		if(isInput)
			oneInterfToISAX = false;
		else 
			oneInterfToISAX = true;
		this.familyName = name;
		this.adjSignal = AdjacentNode.none;
	}
	

	/**
	 * Constructor of SCAIEVNode. Name is generated automatically based on parent node and adjNode. 
	 * @param uniqueID
	 * @param name
	 * @param size
	 * @param isInput default orientation: is an input to the core
	 */
	public SCAIEVNode (SCAIEVNode parentNode, AdjacentNode adjNode, int size, boolean isInput, boolean isSpawn) {
		this.size = size; 
		this.isInput = isInput;
		if(isSpawn && !parentNode.isSpawn())
			this.name = CreateSpawnName(parentNode) + adjNode.suffix;
		else 
			this.name = parentNode.name + adjNode.suffix;
		if(parentNode.isSpawn())
			allowMultipleSpawn = parentNode.allowMultipleSpawn;
		else if(isSpawn)
			allowMultipleSpawn = true;
		this.uniqueID = name.hashCode();
		this.nameParentNode = parentNode.name;
		this.adjSignal = adjNode;
		if(isInput)
			oneInterfToISAX = false;
		else 
			oneInterfToISAX = true;
		this.familyName = parentNode.familyName;
		this.nameCousinNode = parentNode.nameCousinNode;
		this.DH = parentNode.DH;
		this.elements = parentNode.elements;
	}
	
	/**
	 * Clones a SCAIEVNode object.
	 * @param node
	 * @param nameOverride an optional new name for the returned node
	 * @param keepParent if true, will keep the node's parent; otherwise, the returned node will be set as having `node` as parent
	 * @return
	 */
	public static SCAIEVNode CloneNode(SCAIEVNode node, Optional<String> nameOverride, boolean keepParent) {
		SCAIEVNode ret = new SCAIEVNode(node, AdjacentNode.none, node.size, node.isInput, node.isSpawn());
		ret.nameParentNode = keepParent ? node.nameParentNode : node.name;
		ret.name = nameOverride.isPresent() ? nameOverride.get() : node.name;
		ret.uniqueID = ret.name.hashCode();
		ret.adjSignal = node.adjSignal;
		ret.tags.addAll(node.tags);
		return ret;
	}

	/**
	 * @return this, or a cloned SCAIEVNode named to match the node family
	 */
	public SCAIEVNode makeFamilyNode() {
		if (!canRepresentAsFamily())
			return this;
		return CloneNode(this, Optional.of(this.replaceRadixNameWith(familyName)), true);
	}
	
	/**
	 * Determines whether this node is a valid signal for some logic or other node.
	 * For pipelining and reset logic, this indicates that the signal should default to 0. 
	 * Nodes with adj validReq, validData, validResp, addrReq are always considered as 'valid nodes'.
	 * Additionally, {@link SCAIEVNode#isOtherValidNode} can be set to 
	 */
	public boolean isValidNode() {
		return isOtherValidNode || (isAdj() && adjSignal.isValidMarker);
	}
	
	/**
	 * Determines whether this node can be (or already is) converted to a family node.
	 * Specific example: WrMem write data and RdMem read data channels will remain separate,
	 *  whereas WrMem_validReq and RdMem_validReq will be merged to Mem_validReq.
	 */
	public boolean canRepresentAsFamily() {
		return !nameCousinNode.isEmpty() && isAdj() && getAdj() != AdjacentNode.defaultAddr; //HACK: May want to use a node attribute instead of isAdj.
	}
	
	/** 
	 * When generating common module, it is mandatory to have the AdjacentNode as given in this function. For example, in case of WrRD, it is mandatory to compute valid signal. This will be used by core as RegFile[rd] = WrRd_valid ? WrRD : deafult_logic ==> it is mandatory in common logic module to have WrRd_valid signal
	 * @param adjNode
	 * @return
	 */
	public  boolean DefaultMandatoryAdjSig() {
		if(this.adjSignal.equals(AdjacentNode.validReq) || (this.isSpawn() && this.adjSignal.equals(AdjacentNode.validResp)) || (this.adjSignal.equals(AdjacentNode.addrReq) && (elements>1)))
			return true; 
		else 
			return false;
	}
	
	/** 
	 * Function to generate the same SCAIEVNode but with !isInput 
	 * @return
	 */
	public SCAIEVNode NodeNegInput() {
		String newName = this.name;
		SCAIEVNode returnNode = new  SCAIEVNode(newName,this.size,!this.isInput);
		returnNode.adjSignal = this.adjSignal;
		returnNode.familyName = this.familyName;
		returnNode.nameCousinNode = this.nameCousinNode;
		returnNode.allowMultipleSpawn = this.allowMultipleSpawn;
		returnNode.nameParentNode = this.nameParentNode;
		returnNode.oneInterfToISAX = this.oneInterfToISAX;
		returnNode.DH = this.DH;
		return  returnNode;
	}
	
	/** 
	 * is node2 spawn of node1?
	 * @param node1
	 * @param node2
	 * @return
	 */
	public boolean isSpawnOf(SCAIEVNode node1) {
		return this.name.contains( CreateSpawnName(node1) );
	}
	
	/** 
	 * is node2 spawn of node1?
	 * @param node1
	 * @param node2
	 * @return
	 */
	public boolean isSpawn() {
		return this.name.contains(spawnSuffix);
	}
	
	/** 
	 * Make one function to use in different other functions & make sure you create name consistent
	 * @param parentNode
	 */
	private String CreateSpawnName (SCAIEVNode parentNode) {
		return parentNode.name + spawnSuffix;
	}
	public String replaceRadixNameWith (String replace) {
		String suffix = getAdj().suffix;
		if (this.isSpawn()) {
			suffix = spawnSuffix + suffix;
		}
		assert(this.name.endsWith(suffix));
		return replace+"_"+suffix;
	}
	
	public String printInfo() {
		return "Node named: "+name+" with ID = "+uniqueID+", with size "+size+" is Input?"+isInput;
	}
	
	public String getVldName() {
		return this.name+"_valid";
	}
	
	public String getAddrName() {
		return this.name+"_addr";
	}
	
		
		
	public AdjacentNode getAdj() {
		if(this.nameParentNode.isEmpty())
			return AdjacentNode.none;
		else 
			return this.adjSignal;
	}
	
	public boolean isAdj() {
		return !this.nameParentNode.isEmpty() && this.adjSignal != AdjacentNode.none;
	}
	
	public boolean HasParentNode(SCAIEVNode checkNode) {
		return checkNode.name.equals(this.nameParentNode);
	}
	@Override
	public String toString() {
		return name; 
	}
	
	@Override
	public int	hashCode() {
		return uniqueID; 
	} 
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof String)
			return this.name.equals(obj);
		if (!(obj instanceof SCAIEVNode))
			return false;
		return (this.name.equals(((SCAIEVNode)obj).name));
    }

	
}
