package scaiev.frontend;

import java.util.EnumSet;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Pattern;

import scaiev.pipeline.ScheduleFront;

public class SCAIEVNode {
	public enum AdjacentNode {
		none(""),                                   // the base node
		spawnAllowed("_spawnAllowed"),              // for spawn, optional, synchronously keeps spawn fire active 
		validReq("_validReq", AdjacentNode.none),   // ! considered to trigger node and be mandatory
		cancelReq("_cancelReq"),                    // automatically generated by SCAIE-V, set if an ISAX proceeds while keeping validReq low
		validData("_validData", AdjacentNode.none),	// Currently used for wrrd/wrrd_user_node data hazard mechanism. Not mandatory
		validResp("_validResp", AdjacentNode.none), // ! considered to return valid response from core to ISAX
		addr("_addr"),
		addrReq("_addr_valid", AdjacentNode.addr),
		size("_size"),                              // Size for memory accesses, sampled together with addr
		defaultAddr("_defaultAddr"),                // for exp for memory accesses when SCAL needs to get from core the adress
		addrCommited("_addrCommited"),
		isWrite("_write"),                          // for memory transctions for example, to make sure it is a write mem transaction
		;
		
		public final String suffix;
		/** Set to non-null AdjacentNode if this adjacent node indicates the validity of some other node;
		 * Special semantics are needed to differentiate between validReq, validData, validResp for instance. */
		public final AdjacentNode validMarkerFor;
		
		public boolean isValidMarker() {return validMarkerFor != null;} 
		
		private AdjacentNode(String suffix) {
			this.suffix = suffix;
			this.validMarkerFor = null;
		}
		private AdjacentNode(String suffix, AdjacentNode validMarkerFor) {
			this.suffix = suffix;
			this.validMarkerFor = validMarkerFor;
		}
	}
	public enum NodeTypeTag {
		/** The node is a read result that remains valid for the lifetime of an instruction. Should not be combined with {@link NodeTypeTag#nonUniqueReadResult}. */
		staticReadResult,  
		/** 
		 * The node is a read result requested by an instruction (e.g. from memory); the value could get overridden if the instruction sends another request.
		 * Should not be combined with {@link NodeTypeTag#staticReadResult}. 
		 */
		nonStaticReadResult,
		/** The node represents/adds to some per-stage status of the pipeline (stall, flush, etc.). */
		perStageStatus,
		/** No SCAL<->core interface should be generated for this node */
		noCoreInterface,
		/** By default, the core is assumed not to provide this adjacent node even if it provides the base node. It must be explicitly noted in the core's datasheet to support it. */
		defaultNotprovidedByCore,
		/** Port nodes of this (non-adj) base node are supported. */
		supportsPortNodes,
		/** The node is a port node, the name format being "&lt;base node name&gt;_port&lt;port name&gt;&lt;adj suffix&gt;". */
		isPortNode,
		/** The node is only used to mark constraints, such as for all user nodes. */
		constraintMarkerOnlyNode,
		/** The node is used max. once per instruction, but may be present in different stages. */
		accumulatesUntilCommit
	}
	
	// private vars
	private AdjacentNode adjSignal = AdjacentNode.none; // default value. If it doesn't have any parent node, than this value has to be AdjacentNode.none
	
	// public vars
	// Node properties
	public int size; 
	public ScheduleFront commitStage = new ScheduleFront();
	/** default orientation: true means 'is an input to the core', i.e. 'ISAX->SCAL' and/or 'SCAL->Core' */
	public boolean isInput; 
	public String name = "";
	public int nonuniqueID = 0;
	/** Does this node belong to another node (logically) */
	public String nameParentNode = ""; 
	/** for exp. WrStall should have 1 interf/stage to ISAX, but WrRD an interface for each ISAX result. So for WrStall this variable would be true and for WrRD false. By default Wr Nodes have false and Rd Nodes true */
	public boolean oneInterfToISAX = false;
	/** By default true for all spawn nodes. WrPC_spawn should have it false, as no multiple spawn instructions are allowed to concurrently update PC..it doesn't make sense */
	public boolean allowMultipleSpawn = false;
	/** For example, rdmem and wrmem are cousin nodes. Spawn fire logic must be computed for bnoth these nodes because they use the same resources */
	public String nameCousinNode = "";
	/** Don't generate interface to ISAX for this node */
	public boolean noInterfToISAX = false;
	/** used when nameCousinNode not empty. For exp for WrMem and RdMem, familyName = Mem */
	public String familyName = "";
	/** Datahazard required? For exp for WrRD spawn */
	public boolean DH = false;
	/** used by user-added nodes (number of regfile elements) */
	public int elements = 0;
	/** the adjacent node that marks an instance of this node as valid (validReq or addrReq) */
	public AdjacentNode validBy = AdjacentNode.none;
	/** This interf MUST be supported to the core. For exp _write for memory spawn */
	public boolean mustToCore = false;
	public boolean mandatory = false;
	/** The set of tags that applies to this node */
	public Set<NodeTypeTag> tags = EnumSet.noneOf(NodeTypeTag.class);
	
	// Other public vars
	public static final String spawnSuffix = "_spawn";	// 
	public static final String portbaseSuffix = "_port"; //"_port<n>" is the full suffix for port nodes
	public static final Pattern portnamePattern = Pattern.compile("^[a-zA-Z0-9]+$");
	/**
	 * when just name is relevant & size & input irrelevant
	 * @param name
	 */
	public SCAIEVNode (String name) {
		this.name = name;
		this.nonuniqueID = name.hashCode();
		this.familyName = name;
		this.adjSignal = AdjacentNode.none;
	}
	
	/**
	 * Constructor of SCAIEVNode. Name has to be unique (not used by other SCAIEVNodes, as it is used by the hashCode() function.  
	 * @param nonuniqueID
	 * @param name
	 * @param size
	 * @param isInput default orientation: true means 'is an input to the core', i.e. 'ISAX->SCAL' and/or 'SCAL->Core'
	 */
	public SCAIEVNode (String name, int size, boolean isInput) {
		this.size = size; 
		this.isInput = isInput;
		this.name = name;
		this.nonuniqueID = name.hashCode();
		if(isInput)
			oneInterfToISAX = false;
		else 
			oneInterfToISAX = true;
		this.familyName = name;
		this.adjSignal = AdjacentNode.none;
	}
	

	/**
	 * Constructor of SCAIEVNode. Name is generated automatically based on parent node and adjNode. 
	 * @param nonuniqueID
	 * @param name
	 * @param size
	 * @param isInput default orientation: is an input to the core
	 */
	public SCAIEVNode (SCAIEVNode parentNode, AdjacentNode adjNode, int size, boolean isInput, boolean isSpawn) {
		this.size = size; 
		this.isInput = isInput;
		if(isSpawn && !parentNode.isSpawn())
			this.name = CreateSpawnName(parentNode) + adjNode.suffix;
		else 
			this.name = parentNode.name + adjNode.suffix;
		if(parentNode.isSpawn())
			allowMultipleSpawn = parentNode.allowMultipleSpawn;
		else if(isSpawn)
			allowMultipleSpawn = true;
		this.nonuniqueID = name.hashCode();
		this.nameParentNode = parentNode.name;
		this.adjSignal = adjNode;
		if(isInput)
			oneInterfToISAX = false;
		else 
			oneInterfToISAX = true;
		this.familyName = parentNode.familyName;
		this.nameCousinNode = parentNode.nameCousinNode;
		this.DH = parentNode.DH;
		this.elements = parentNode.elements;
	}
	
	/**
	 * Clones a SCAIEVNode object.
	 * @param node
	 * @param nameOverride an optional new name for the returned node
	 * @param keepParent if true, will keep the node's parent; otherwise, the returned node will be set as having `node` as parent
	 * @return
	 */
	public static SCAIEVNode CloneNode(SCAIEVNode node, Optional<String> nameOverride, boolean keepParent) {
		SCAIEVNode ret = new SCAIEVNode(node, AdjacentNode.none, node.size, node.isInput, node.isSpawn());
		ret.nameParentNode = keepParent ? node.nameParentNode : node.name;
		ret.name = nameOverride.isPresent() ? nameOverride.get() : node.name;
		ret.nonuniqueID = ret.name.hashCode();
		ret.adjSignal = node.adjSignal;
		ret.tags.addAll(node.tags);
		
		ret.commitStage = node.commitStage;
		ret.oneInterfToISAX = node.oneInterfToISAX;
		ret.allowMultipleSpawn = node.allowMultipleSpawn;
		ret.nameCousinNode = node.nameCousinNode;
		ret.noInterfToISAX = node.noInterfToISAX;
		ret.DH = node.DH;
		ret.elements = node.elements;
		ret.validBy = node.validBy;
		ret.mustToCore = node.mustToCore;
		ret.mandatory = node.mandatory;
		return ret;
	}
	
	/**
	 * Creates a port node. If baseNodeWithAdj is adjacent, the returned port node will be created as an adjacent to the port base node.
	 * The port node name will follow the format "&lt;base node name&gt;_port&lt;port name&gt;&lt;adj suffix&gt;".
	 * NOTE: Does not check for {@link NodeTypeTag#supportsPortNodes}.
	 * @param baseNodeWithAdj the base portless node (or an adjacent node) 
	 * @param portName the port name
	 * @return
	 */
	public static SCAIEVNode makePortNodeOf(SCAIEVNode baseNodeWithAdj, String portName) {
		if (!portnamePattern.matcher(portName).matches()) {
			throw new IllegalArgumentException("The given port name does not match the pattern '" + portnamePattern.toString() + "'");
		}
		String baseNodeNonadjName = baseNodeWithAdj.isAdj() ? baseNodeWithAdj.nameParentNode : baseNodeWithAdj.name;
		String portBaseNodeName = baseNodeNonadjName + "_port" + portName;
		String adjPortNodeName = portBaseNodeName + baseNodeWithAdj.getAdj().suffix;
		SCAIEVNode ret = CloneNode(baseNodeWithAdj, Optional.of(adjPortNodeName), true);
		ret.nameParentNode = ret.isAdj() ? portBaseNodeName : baseNodeNonadjName;
		ret.tags.remove(NodeTypeTag.supportsPortNodes);
		ret.tags.add(NodeTypeTag.isPortNode);
		return ret;
	}

	/**
	 * @return this, or a cloned SCAIEVNode named to match the node family
	 */
	public SCAIEVNode makeFamilyNode() {
		if (!canRepresentAsFamily())
			return this;
		return CloneNode(this, Optional.of(this.replaceRadixNameWith(familyName)), true);
	}
	
	/**
	 * Determines whether this node is a valid signal for some logic or other node.
	 * For pipelining and reset logic, this indicates that the signal should default to 0. 
	 * Nodes with adj validReq, validData, validResp, addrReq are always considered as 'valid nodes'.
	 */
	public boolean isValidNode() {
		return adjSignal.isValidMarker();
	}
	
	/**
	 * Determines whether this node can be (or already is) converted to a family node.
	 * Specific example: WrMem write data and RdMem read data channels will remain separate,
	 *  whereas WrMem_validReq and RdMem_validReq will be merged to Mem_validReq.
	 */
	public boolean canRepresentAsFamily() {
		return !nameCousinNode.isEmpty() && isAdj() && getAdj() != AdjacentNode.defaultAddr; //HACK: May want to use a node attribute instead of isAdj.
	}
	
	/** 
	 * When generating common module, it is mandatory to have the AdjacentNode as given in this function. For example, in case of WrRD, it is mandatory to compute valid signal. This will be used by core as RegFile[rd] = WrRd_valid ? WrRD : deafult_logic ==> it is mandatory in common logic module to have WrRd_valid signal
	 * @param adjNode
	 * @return
	 */
	public  boolean DefaultMandatoryAdjSig() {
		if(this.adjSignal.equals(AdjacentNode.validReq) || (this.isSpawn() && this.adjSignal.equals(AdjacentNode.validResp)) || (this.adjSignal.equals(AdjacentNode.addrReq) && (elements>1)))
			return true; 
		else 
			return false;
	}
	
	/** 
	 * Function to generate the same SCAIEVNode but with !isInput 
	 * @return
	 */
	public SCAIEVNode NodeNegInput() {
		SCAIEVNode ret = CloneNode(this, Optional.empty(), true);
		ret.isInput = !ret.isInput;
		String newName = this.name;
		SCAIEVNode returnNode = new  SCAIEVNode(newName,this.size,!this.isInput);
		returnNode.adjSignal = this.adjSignal;
		returnNode.familyName = this.familyName;
		returnNode.nameCousinNode = this.nameCousinNode;
		returnNode.allowMultipleSpawn = this.allowMultipleSpawn;
		returnNode.nameParentNode = this.nameParentNode;
		returnNode.oneInterfToISAX = this.oneInterfToISAX;
		returnNode.DH = this.DH;
		return  returnNode;
	}
	
	/** 
	 * is node2 spawn of node1?
	 * @param node1
	 * @param node2
	 * @return
	 */
	public boolean isSpawnOf(SCAIEVNode node1) {
		return this.name.contains( CreateSpawnName(node1) );
	}
	
	/** 
	 * is node2 spawn of node1?
	 * @param node1
	 * @param node2
	 * @return
	 */
	public boolean isSpawn() {
		return this.name.contains(spawnSuffix);
	}
	
	/** 
	 * Make one function to use in different other functions & make sure you create name consistent
	 * @param parentNode
	 */
	private String CreateSpawnName (SCAIEVNode parentNode) {
		return parentNode.name + spawnSuffix;
	}
	public String replaceRadixNameWith (String replace) {
		String suffix = getAdj().suffix;
		if (this.isSpawn()) {
			suffix = spawnSuffix + suffix;
		}
		assert(this.name.endsWith(suffix));
		return replace+"_"+suffix;
	}
		
	public AdjacentNode getAdj() {
		if(this.nameParentNode.isEmpty())
			return AdjacentNode.none;
		else 
			return this.adjSignal;
	}
	
	public boolean isAdj() {
		return !this.nameParentNode.isEmpty() && this.adjSignal != AdjacentNode.none;
	}
	
	public boolean HasParentNode(SCAIEVNode checkNode) {
		return checkNode.name.equals(this.nameParentNode);
	}
	@Override
	public String toString() {
		return name; 
	}
	
	@Override
	public int	hashCode() {
		return nonuniqueID; 
	} 
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof String)
			return this.name.equals(obj);
		if (!(obj instanceof SCAIEVNode))
			return false;
		return (this.name.equals(((SCAIEVNode)obj).name));
    }

	
}
