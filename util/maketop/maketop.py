# Definitions for top module file generation based on the netlist generated by SCAIE-V.
# Argument 1: Path to the core source directory, where the netlist will be read from and the top file will be written in.
# Argument 2 (optional): Path to the yaml description directory, where each (System)Verilog module corresponds to one yaml detailing the module's ISAXes.

import sys
import os
import yaml
import itertools

class SCALPinNet:
    tag1 = 'tag:yaml.org,2002:scaiev.frontend.SCALPinNet'
    tag2 = 'tag:yaml.org,2002:scaiev.scal.SCALPinNet'
    
    def SCALPinNet(self):
        self.core_module_pin = ''
        self.isax_module_pin = ''
        self.scal_module_pin = ''
        self.isaxes = set([])
        self.size = 0
    
    def from_yaml(loader, node):
        ret = SCALPinNet()
        for (name,val) in node.value:
            match name.value:
                case 'core_module_pin':
                    ret.core_module_pin = val.value
                case 'isax_module_pin':
                    ret.isax_module_pin = val.value
                case 'scal_module_pin':
                    ret.scal_module_pin = val.value
                case 'size':
                    ret.size = int(val.value)
                case 'isaxes':
                    ret.isaxes = set([arrval.value for arrval in val.value])
        return ret

if len(sys.argv) < 2:
    print("Missing argument 1: Directory where the top module should be written to. Must contain scaiev_netlist.yaml.", file=sys.stderr)
    sys.exit(1)
dir_coresrc = sys.argv[1]
if len(sys.argv) < 3:
    print("Missing optional argument 2: ISAX yaml description directory. Assuming each ISAX is in a separate module.", file=sys.stderr)
dir_isaxes = None if len(sys.argv) <= 2 else sys.argv[2]

SCAIEV_MODULE_CLK = "clk_i"
SCAIEV_MODULE_RST = "rst_i"
MODULE_TAB = "    "

def parse_netlist():
    yaml.add_constructor(SCALPinNet.tag1, SCALPinNet.from_yaml, Loader=yaml.SafeLoader)
    yaml.add_constructor(SCALPinNet.tag2, SCALPinNet.from_yaml, Loader=yaml.SafeLoader)
    with open(dir_coresrc + "/scaiev_netlist.yaml", 'r') as netlist_file:
        ret = yaml.safe_load(netlist_file)
        return {} if ret is None else ret
    
    #netlist: dict {wire name: net}

def generate_module_isax_mapping(netlist):
    isaxes_without_module = set()
    for wirename, net in netlist.items():
        # While we're here, remove known pseudo-ISAXes.
        if "disaxkill" in net.isaxes:
            net.isaxes.remove("disaxkill")
        if "disaxfence" in net.isaxes:
            net.isaxes.remove("disaxfence")
        isaxes_without_module.update(net.isaxes)

    isax_modules = {}
    # Parse each module yaml file to generate the mapping from module to ISAXes.
    if dir_isaxes is not None and len(dir_isaxes)>0:
        # Hoping that the directory has a decently low number of files, else this will be slow and memory-heavy.
        isax_searchdirs = [dir_isaxes] + [dirpath for dirpath
            in ["%s/%s"%(dir_isaxes,dirname) for dirname in os.listdir(dir_isaxes) if not dirname.startswith("skip_")]
            if os.path.isdir(dirpath)
        ]
        isax_candidatepaths = []
        for searchdir in isax_searchdirs:
            isax_candidatepaths += [("%s/%s"%(searchdir,fname),fname[:-5]) for fname in os.listdir(searchdir) if fname.startswith("ISAX_") and fname.endswith(".yaml")]
        for (isax_candidatepath,modulename) in isax_candidatepaths:
            if modulename in isax_modules:
                print("WARNING: Ignoring repeated occurrence of %s.yaml" % modulename, file=sys.stderr)
                continue
            with open(isax_candidatepath, 'r') as candidate_file:
                candidate_data = yaml.safe_load(candidate_file)
                module_instr_candidates = itertools.chain.from_iterable(((instrdesc[keyname] for keyname in ['instruction','always'] if (keyname in instrdesc)) for instrdesc in candidate_data))
                module_instructions = [instr for instr in module_instr_candidates if (instr in isaxes_without_module)]
                for module_instr in module_instructions:
                    isaxes_without_module.remove(module_instr)
                if len(module_instructions) != 0:
                    isax_modules[modulename] = module_instructions
    # Add all remaining ISAXes to a new module with prefix "ISAX_".
    for remaining_isax in isaxes_without_module:
        modulename = remaining_isax if remaining_isax.startswith("ISAX") else ("ISAX_%s" % remaining_isax) 
        if modulename in isax_modules:
            print("WARNING: Module %s for ISAX %s exists without containing the ISAX. Adding..." % (modulename, remaining_isax), file=sys.stderr)
            isax_modules[modulename].append(remaining_isax)
        else:
            isax_modules[modulename] = [remaining_isax]
    return isax_modules

def write_top(template_file_name, out_file_name, core_pin_name_translator=None):
    netlist = parse_netlist()
    isax_modules = generate_module_isax_mapping(netlist)
    with open(template_file_name, 'r') as in_top_file, open("%s/%s" % (dir_coresrc, out_file_name), 'w') as out_top_file:
        for line in in_top_file:
            line_lstrip = line.lstrip()
            line_strip = line_lstrip.rstrip()
            line_tabs = line[0:len(line)-len(line_lstrip)]
            match line_strip:
                case '//SCAIEV MAKETOP COREWIRES':
                    for wirename, net in netlist.items():
                        if len(net.core_module_pin) != 0:
                            out_top_file.write(line_tabs + "wire " + ("["+str(net.size)+"-1:0] " if net.size != 1 else "") + wirename + ";\n")
                case '//SCAIEV MAKETOP COREPINS':
                    for wirename, net in netlist.items():
                        if len(net.core_module_pin) != 0:
                            out_top_file.write(line_tabs + (",.%s(%s)\n" % (core_pin_name_translator(net.core_module_pin), wirename)))
                case '//SCAIEV MAKETOP ISAXWIRES':
                    # SCAL ports can have several netlist entries to support different ISAX-side port names.
                    # In such cases, the netlist key name has another identifier after a " " character (usually the ISAX name) to prevent duplicates.
                    added_netlist_wires = set()
                    for wirename, net in netlist.items():
                        wirename_actual = wirename.split(" ")[0]
                        if len(net.core_module_pin) == 0 and len(net.isax_module_pin) != 0 and not (wirename_actual in added_netlist_wires):
                            out_top_file.write(line_tabs + "wire " + ("["+str(net.size)+"-1:0] " if net.size != 1 else "") + wirename_actual + ";\n")
                            added_netlist_wires.add(wirename_actual)
                case '//SCAIEV MAKETOP SCAL':
                    for wirename, net in netlist.items():
                        if len(net.core_module_pin) == 0 and len(net.isax_module_pin) == 0:
                            assert False, "Stray wire %s for SCAL module, pin %s" % (wirename, net.scal_module_pin)
                            if len(net.scal_module_pin) != 0:
                                out_top_file.write(line_tabs + "wire " + ("["+str(net.size)+"-1:0] " if net.size != 1 else "") + wirename + ";\n")
                    out_top_file.write(line_tabs + "SCAL scal (\n")
                    out_top_file.write(line_tabs + MODULE_TAB + "." + SCAIEV_MODULE_CLK + "(clk)\n")
                    out_top_file.write(line_tabs + MODULE_TAB + ",." + SCAIEV_MODULE_RST + "(rst)\n")
                    
                    #Similar to ISAXWIRES, only prevent duplicate SCAL-side ports.
                    added_scal_ports = set()
                    for wirename, net in netlist.items():
                        wirename_actual = wirename.split(" ")[0]
                        if len(net.scal_module_pin) != 0 and not (wirename_actual in added_scal_ports):
                            out_top_file.write(line_tabs + MODULE_TAB + (",.%s(%s)\n" % (net.scal_module_pin, wirename_actual)))
                            added_scal_ports.add(wirename_actual)
                    out_top_file.write(line_tabs + ");\n")
                case '//SCAIEV MAKETOP ISAXINST':
                    for isax_module, isaxes in isax_modules.items():
                        out_top_file.write(line_tabs + "%s %s (\n" % (isax_module, isax_module.lower()))
                        out_top_file.write(line_tabs + MODULE_TAB + "." + SCAIEV_MODULE_CLK + "(clk)\n")
                        out_top_file.write(line_tabs + MODULE_TAB + ",." + SCAIEV_MODULE_RST + "(rst)\n")
                        for wirename, net in netlist.items():
                            wirename_actual = wirename.split(" ")[0]
                            if len(net.isax_module_pin) == 0:
                                continue
                            has_overlap = False
                            for isax in isaxes:
                                if isax in net.isaxes:
                                    has_overlap = True
                                    break
                            if not has_overlap:
                                continue
                            out_top_file.write(line_tabs + MODULE_TAB + (",.%s(%s)\n" % (net.isax_module_pin, wirename_actual)))
                        out_top_file.write(line_tabs + ');\n\n')
                            
                case _:
                    out_top_file.write(line)

if __name__ == "__main__":
    print("maketop.py is not a standalone script. You may be looking for another script that calls write_top.", file=sys.stderr)

