# Definitions for top module file generation based on the netlist generated by SCAIE-V.
# Argument 1: Path to the core source directory, where the netlist will be read from and the top file will be written in.
# Argument 2 (optional): Path to the yaml description directory, where each (System)Verilog module corresponds to one yaml detailing the module's ISAXes.
#  Searches in the directory itself and its subdirs, skipping subdirs named 'skip_*'
#   Searches for ISAX_*.yaml files to correctly assign instructions/always blocks to the ISAX module
#   Searches for netlist_*.yaml files that add additional entries to the netlist

import sys
import os
import yaml
import itertools

SCAIEV_MODULE_CLK = "clk_i"
SCAIEV_MODULE_RST = "rst_i"
MODULE_TAB = "    "

class SCALPinNet:
    tag1 = 'tag:yaml.org,2002:scaiev.frontend.SCALPinNet'
    tag2 = 'tag:yaml.org,2002:scaiev.scal.SCALPinNet'
    
    def __init__(self):
        self.core_module_pin = ''
        self.isax_module_pin = ''
        self.scal_module_pin = ''
        self.wrapper_module_pin = ''
        self.wrapper_isinput = False
        self.isaxes = set([])
        self.size = 0
    
    def from_yaml(loader, node):
        ret = SCALPinNet()
        for (name,val) in node.value:
            match name.value:
                case 'core_module_pin':
                    ret.core_module_pin = val.value
                case 'isax_module_pin':
                    ret.isax_module_pin = val.value
                case 'scal_module_pin':
                    ret.scal_module_pin = val.value
                case 'wrapper_module_pin':
                    ret.wrapper_module_pin = val.value
                case 'wrapper_isinput':
                    match val.value:
                        case False: ret.wrapper_isinput = False
                        case 0: ret.wrapper_isinput = False
                        case 'false': ret.wrapper_isinput = False
                        case '0': ret.wrapper_isinput = False
                        case True: ret.wrapper_isinput = True
                        case 1: ret.wrapper_isinput = True
                        case 'true': ret.wrapper_isinput = True
                        case '1': ret.wrapper_isinput = True
                        case _: raise TypeError("wrapper_isinput should be assigned a bool (true or false)")
                case 'size':
                    ret.size = int(val.value)
                case 'isaxes':
                    ret.isaxes = set([arrval.value for arrval in val.value])
        return ret

if len(sys.argv) < 2:
    print("Missing argument 1: Directory where the top module should be written to. Must contain scaiev_netlist.yaml.", file=sys.stderr)
    sys.exit(1)
dir_coresrc = sys.argv[1]
if len(sys.argv) < 3:
    print("Missing optional argument 2: ISAX yaml description directory. Assuming each ISAX is in a separate module.", file=sys.stderr)
dir_isaxes = None if len(sys.argv) <= 2 else sys.argv[2]

def parse_netlist(netlist_path):
    yaml.add_constructor(SCALPinNet.tag1, SCALPinNet.from_yaml, Loader=yaml.SafeLoader)
    yaml.add_constructor(SCALPinNet.tag2, SCALPinNet.from_yaml, Loader=yaml.SafeLoader)
    with open(netlist_path, 'r') as netlist_file:
        ret = yaml.safe_load(netlist_file)
        return {} if ret is None else ret
    #netlist: dict {wire name: net}

def generate_module_isax_mapping(netlist):
    isaxes_without_module = set()
    for wirename, net in netlist.items():
        # While we're here, remove known pseudo-ISAXes.
        if "disaxkill" in net.isaxes:
            net.isaxes.remove("disaxkill")
        if "disaxfence" in net.isaxes:
            net.isaxes.remove("disaxfence")
        isaxes_without_module.update(net.isaxes)

    isax_modules = {}
    # Parse each module yaml file to generate the mapping from module to ISAXes.
    if dir_isaxes is not None and len(dir_isaxes)>0:
        # Hoping that the directory has a decently low number of files, else this will be slow and memory-heavy.
        isax_searchdirs = [dir_isaxes] + [dirpath for dirpath
            in ["%s/%s"%(dir_isaxes,dirname) for dirname in os.listdir(dir_isaxes) if not dirname.startswith("skip_")]
            if os.path.isdir(dirpath)
        ]
        isax_candidatepaths = []
        isax_netlistpaths = []
        for searchdir in isax_searchdirs:
            isax_candidatepaths += [("%s/%s"%(searchdir,fname),fname[:-5]) for fname in os.listdir(searchdir) if fname.startswith("ISAX_") and fname.endswith(".yaml")]
            isax_netlistpaths += [("%s/%s"%(searchdir,fname)) for fname in os.listdir(searchdir) if fname.startswith("netlist_") and fname.endswith(".yaml")]
        # Match instructions/always blocks against ISAX modules
        for (isax_candidatepath,modulename) in isax_candidatepaths:
            if modulename in isax_modules:
                print("WARNING: Ignoring repeated occurrence of %s.yaml" % modulename, file=sys.stderr)
                continue
            with open(isax_candidatepath, 'r') as candidate_file:
                candidate_data = yaml.safe_load(candidate_file)
                module_instr_candidates = itertools.chain.from_iterable(((instrdesc[keyname] for keyname in ['instruction','always'] if (keyname in instrdesc)) for instrdesc in candidate_data))
                module_instructions = [instr for instr in module_instr_candidates if (instr in isaxes_without_module)]
                for module_instr in module_instructions:
                    isaxes_without_module.remove(module_instr)
                if len(module_instructions) != 0:
                    isax_modules[modulename] = module_instructions
        # Parse additional netlist files
        for isax_netlistpath in isax_netlistpaths:
            isax_netlist = parse_netlist(isax_netlistpath)
            conflicts_str = ','.join((net_wirename for net_wirename in isax_netlist if (net_wirename in netlist)))
            if conflicts_str != '':
                print("WARNING: Encountered duplicate netlist entries while parsing %s: Overwriting %s" % (isax_netlistpath, conflicts_str), file=sys.stderr)
            netlist.update(isax_netlist)
    # Add all remaining ISAXes to a new module with prefix "ISAX_".
    for remaining_isax in isaxes_without_module:
        modulename = remaining_isax if remaining_isax.startswith("ISAX") else ("ISAX_%s" % remaining_isax) 
        if modulename in isax_modules:
            print("WARNING: Module %s for ISAX %s exists without containing the ISAX. Adding..." % (modulename, remaining_isax), file=sys.stderr)
            isax_modules[modulename].append(remaining_isax)
        else:
            isax_modules[modulename] = [remaining_isax]
    return isax_modules

def _anydecl(decltype, size, name):
    return ("%s [%d-1:0] %s" % (decltype, size, name)) if size != 1 else ("%s %s" % (decltype, name))
def _iodecl(decltype, size, name):
    return ", " + _anydecl(decltype, size, name) + "\n"
def _wiredecl(wirename, net):
    return _anydecl("wire", net.size, wirename) + ";\n"
def _assign(a, b):
    return "assign %s = %s;\n" % (a, b)


def write_top(template_file_name, out_file_name, core_pin_name_translator=None):
    netlist = parse_netlist(dir_coresrc + "/scaiev_netlist.yaml")
    isax_modules = generate_module_isax_mapping(netlist)
    with open(template_file_name, 'r') as in_top_file, open("%s/%s" % (dir_coresrc, out_file_name), 'w') as out_top_file:
        for line in in_top_file:
            line_lstrip = line.lstrip()
            line_strip = line_lstrip.rstrip()
            line_tabs = line[0:len(line)-len(line_lstrip)]
            match line_strip:
                case '//SCAIEV MAKETOP WRAPPERIO':
                    added_wrapper_pins = {}
                    for wirename, net in netlist.items():
                        if len(net.wrapper_module_pin) != 0:
                            if net.wrapper_module_pin not in added_wrapper_pins:
                                inout = 'input' if net.wrapper_isinput else 'output'
                                out_top_file.write(line_tabs + _iodecl(inout + ' wire', net.size, net.wrapper_module_pin))
                                added_wrapper_pins[net.wrapper_module_pin] = net.wrapper_isinput
                            elif net.wrapper_isinput != added_wrapper_pins[net.wrapper_module_pin]:
                                print('ERROR: Inconsistent net directory for wrapper pin %s' % net.wrapper_module_pin, file=sys.stderr)
                case '//SCAIEV MAKETOP COREWIRES':
                    for wirename, net in netlist.items():
                        wirename_actual = wirename.split(" ")[0]
                        #wrapper-* with net name != top name
                        if len(net.wrapper_module_pin) != 0 and \
                                wirename != net.wrapper_module_pin:
                            out_top_file.write(line_tabs + _wiredecl(wirename, net))
                            if net.wrapper_isinput:
                                out_top_file.write(line_tabs + _assign(wirename, net.wrapper_module_pin))
                            else:
                                out_top_file.write(line_tabs + _assign(net.wrapper_module_pin, wirename))
                        #core-*
                        elif len(net.core_module_pin) != 0:
                            out_top_file.write(line_tabs + _wiredecl(wirename, net))
                case '//SCAIEV MAKETOP COREPINS':
                    for wirename, net in netlist.items():
                        if len(net.core_module_pin) != 0:
                            out_top_file.write(line_tabs + (",.%s(%s)\n" % (core_pin_name_translator(net.core_module_pin), wirename)))
                case '//SCAIEV MAKETOP ISAXWIRES':
                    # SCAL ports can have several netlist entries to support different ISAX-side port names.
                    # In such cases, the netlist key name has another identifier after a " " character (usually the ISAX name) to prevent duplicates.
                    added_netlist_wires = set()
                    for wirename, net in netlist.items():
                        wirename_actual = wirename.split(" ")[0]
                        if len(net.core_module_pin) == 0 and \
                                len(net.isax_module_pin) != 0 and \
                                len(net.wrapper_module_pin) == 0 and \
                                not (wirename_actual in added_netlist_wires):
                            out_top_file.write(line_tabs + _wiredecl(wirename_actual, net))
                            added_netlist_wires.add(wirename_actual)
                case '//SCAIEV MAKETOP SCAL':
                    for wirename, net in netlist.items():
                        if len(net.core_module_pin) == 0 and len(net.isax_module_pin) == 0 and len(net.wrapper_module_pin) == 0:
                            assert False, "Stray wire %s for SCAL module, pin %s" % (wirename, net.scal_module_pin)
                            if len(net.scal_module_pin) != 0:
                                out_top_file.write(line_tabs + _wiredecl(wirename, net))
                    out_top_file.write(line_tabs + "SCAL scal (\n")
                    out_top_file.write(line_tabs + MODULE_TAB + (".%s(%s)\n" % (SCAIEV_MODULE_CLK, "clk")))
                    out_top_file.write(line_tabs + MODULE_TAB + (",.%s(%s)\n" % (SCAIEV_MODULE_RST, "rst")))
                    
                    #Similar to ISAXWIRES, only prevent duplicate SCAL-side ports.
                    added_scal_ports = set()
                    for wirename, net in netlist.items():
                        wirename_actual = wirename.split(" ")[0]
                        if len(net.scal_module_pin) != 0 and not (wirename_actual in added_scal_ports):
                            out_top_file.write(line_tabs + MODULE_TAB + (",.%s(%s)\n" % (net.scal_module_pin, wirename_actual)))
                            added_scal_ports.add(wirename_actual)
                    out_top_file.write(line_tabs + ");\n")
                case '//SCAIEV MAKETOP ISAXINST':
                    for isax_module, isaxes in isax_modules.items():
                        out_top_file.write(line_tabs + "%s %s (\n" % (isax_module, isax_module.lower()))
                        out_top_file.write(line_tabs + MODULE_TAB + (".%s(%s)\n" % (SCAIEV_MODULE_CLK, "clk")))
                        out_top_file.write(line_tabs + MODULE_TAB + (",.%s(%s)\n" % (SCAIEV_MODULE_RST, "rst")))
                        for wirename, net in netlist.items():
                            wirename_actual = wirename.split(" ")[0]
                            if len(net.isax_module_pin) == 0:
                                continue
                            has_overlap = False
                            for isax in isaxes:
                                if isax in net.isaxes:
                                    has_overlap = True
                                    break
                            if not has_overlap:
                                continue
                            out_top_file.write(line_tabs + MODULE_TAB + (",.%s(%s)\n" % (net.isax_module_pin, wirename_actual)))
                        out_top_file.write(line_tabs + ');\n\n')
                            
                case _:
                    out_top_file.write(line)

if __name__ == "__main__":
    print("maketop.py is not a standalone script. You may be looking for another script that calls write_top.", file=sys.stderr)

